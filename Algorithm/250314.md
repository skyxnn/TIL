**250314 | [Algorithm2] Hash 추가 설명**

## [1] Hash
### 1. Hash
#### 1) Hash
- 개념
    - 데이터를 고정된 크기의 값으로 변환하는 과정.
- 특징
    - 변환된 해시 값(Hash Value)은 원본 데이터를 고유하게 식별하거나 데이털르 빠르게 검색하는데 사용.

#### 2) Hash Function
- 개념
    - 입력값을 고정된 크기의 해시 값으로 변환하는 함수.
- 좋은 해시 함수
    - 결론적 특성 : 동일한 입력은 항상 동일한 해시값을 생성해야 함.
    - 균등한 분포 : 해시 값이 균등하게 분포되어야 함.
    - 충돌 최소화 : 다른 입력값이 동일한 해시값을 생성하는 경우가 낮아야 함.
    - 눈사태 효과 : 입력의 작은 변화가 출력의 큰 변화를 야기해야 함(유사한 입력들이 다른 해시 값을 가지게 하여 클러스터링 방지).
    - 효율성 : 계산 속도가 빨라야 함.
    - 저항성 : 입력값을 예쌍하기 어려워야 함.

#### 3) Hash Table
- 개념
    - 해시 값을 인덱스로 사용하여 데이터를 저장하고 검색하는 자료구조.
- 특징
    - 대부분의 경우, 상수 시간(O(1)) 내에 데이터 검색/삽입/삭제.

### 2. Hash Function 종류
#### 1) Division Hash Function
- 개념
    - 키(Key)를 해시 테이블의 크기로 나눈 나머지를 해시 값으로 사용하는 나머지 연산 해시 함수.
- 특징
    - 가장 기본적인 해시 함수.
    - 구현이 매우 간단하고, 이해하기 쉬움.
    - 계산 속도가 빠름(효율성).
    - h(k) = k mod m (k = 해시할 키 값, m = 해시 테이블 크기)
- 장점
    - 정수 키에 대해 효과적으로 작동.
    - 해시 테이블의 크기를 적절히 선택하면 좋은 성능 발휘.
- 단점
    - 테이블 크기 선택에 민감(주로 소수, 2의 거듭 제곱을 활용).
    - 특정 패턴의 키에 대해 성능 저하 가능.
    - 문자열이나 복잡한 키는 추가적인 처리 필요.

#### 2) Multiplication Hash Function
- 개념
    - 키(Key)를 0과 1 사이의 실수로 변환한 후, 이를 해시 테이블의 크기와 곱하여 해시 값으로 사용하는 곱셈 해시 함수.
- 특징
    - 해시 테이블의 크기에 덜 민감.
    - h(k) = k A mod m (k = 해시할 키 값, m = 해시 테이블 크기, A = 0 ~ 1의 실수)
    - A 값의 선택이 중요함(일반적으로 $(\sqrt 5 -1) / 2 0.6180339887$)
- 장점
    - 키의 분포에 덜 민감함.
    - 나머지 연산 해시 함수보다 더 균일한 분포를 제공.
- 단점
    - 구현이 조금 더 복잡함.
    - 부동 소수점 연산을 사용하므로 정밀도 문제가 발생할 수 있음.

#### 3) Folding Hash Function
- 개념
    - 키(Key)를 여러 부분으로 나누고, 이 부분들을 조합하여 최종 해시 값으로 사용하는 폴딩 해시 함수.
- 작동 원리
    1. 키를 일정 크기의 부분으로 나눔. (ex. 2자리 / 3자리 / ...)
    2. 나눈 부분들을 모두 더함.
    3. 최종 합을 해시 테이블 크기로 나눈 나머지를 해시 값으로 사용.
- 장점
    - 긴 키나 문자열에 효과적임.
    - 키의 모든 부분이 최종 해시 값에 기여하므로 균일한 분포.
    - 구현이 간단함.
- 단점
    - 짧은 키에 대해서는 오버헤드가 있을 수 있음.
    - 폴딩 크기가 성능에 영향을 미침.

#### 4) Polynomial Hash Function
- 개념
    - 문자열을 다항식으로 표현하여 해시 값을 계산하는 다항식 해시 함수.
- 특징
    - 라빈-카프 알고리즘, 데이터베이스 인덱싱 등 다양한 분야에서 활용.
- 장점
    - 문자열 비교에 효과적임.
    - 문자열 패턴 매칭 알고리즘에 유용(라빈-카프 알고리즘).
    - 간단하면서도 효과적인 해시 분포를 제공함.
- 단점
    - 긴 문자열에 대해서는 오버플로우가 있을 수 있음.

#### 5) SHA-256 (Secure Hash Algorithm 256-bit)
- 개념
    - 임의의 길이의 입력 데이터를 고정된 크기의 256비트(32바이트) 해시 값으로 변환하는 함수.
- 특징
    - 현대적이고 널리 사용되는 암호학적 해시 함수.
    - 입력의 작은 변화가 출력의 큰 변화를 야기함(눈사태 효과).
    - 같은 해시 값을 가진 두 개의 다른 입력을 찾기가 매우 어려움(저항성).

## [2] Hash Collision
### 1. Hash Collision
#### 1) Hash Collision (해시 충돌)
- 개념
    - 두 개 이상의 서로 다른 키가 동일한 해시 값을 생성하는 상황.
- 원인
    - 해시 값의 범위가 제한적이기 때문에 서로 다른 입력 데이터가 동일한 해시 값을 가질 가능성이 존재(비둘기집 원리).
    - 해시 함수가 입력 데이터를 균등하게 분포시키지 못하면 충돌이 빈번하게 발생.
    - 무한한 입력을 유한한 출력(한정된 해시 테이블)로 매핑하는 과정에서 발생.
- 영향
    - 성능 저하
    - 보안 위험
    - 데이터 무결성 문제
- 해결 방법
    - 개방 주소법(Open Addressing)
    - Chaining
    - Separate Chaining

### 2. Hash Collision 해결 방법
#### 1) Chaining
- 개념
    - 해시 테이블의 각 버킷에 연결 리스트를 사용하여 충돌이 발생한 항목을 저장.
- 작동 원리
    1. 해시 함수를 통해 키의 해시 값을 계산.
    2. 계산된 해시 값에 해당하는 버킷에 항목을 저장.
    3. 충돌이 발생하면, 해당 버킷의 연결 리스트에 새 항목을 추가.
- 장점
    - 구현이 비교적 간단.
    - 해시 테이블의 크기를 동적으로 조절하기 쉬움.
    - 키의 전체 또는 일부를 저장할 수 있어 보안에 유리함.
- 단점
    - 연결 리스트를 위한 추가 메모리가 필요.
    - 최악의 경우에 검색 시간이 O(n)이 될 수 있어 캐시 성능이 개방 주소법에 비해 떨어질 수 있음.

#### 2) 개방 주소법(Open Addressing)
- 개념
    - 모든 키-값 쌍을 해시 테이블 배열 내에 직접 저장하고 충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장.
- 특징
    - 모든 데이터가 해시 테이블 배열 내에 저장.
    - 별도의 체인이나 추가 데이터 구조가 필요 없음.
- 방법
    1. 선형 탐사(Linear Probing)
        - 개념 : 충돌이 발생한 경우, 순차적으로 다음 버킷을 검사하여 빈 슬롯을 찾는 방식.
        - 장점 : 구현 간단, 캐시 성능 좋음, 추가 메모리 불필요.
        - 단점 : 클러스터링 문제(연속된 항목들이 몰리는 현상 발생 가능), 최악의 경우 검색 시간이 O(n)이 될 수 있음.
    2. 제곱 탐사(Quadratic Probing)
        - 개념 : 충돌이 발생했을 때, 원래의 해시 값에서 제곱수만큼 떨어진 위치를 순차적으로 탐색.
        - 장점 : 선형 탐사에 비해 클러스터링 문제가 덜함, 충돌 해결을 더 넓은 범위로 함, 캐시 성능이 좋음.
        - 단점 : 이차 클러스터링이 발생할 수 있음, 테이블이 절반 이상 차면 성능 급격히 저하 가능, 모든 버킷을 탐색하지 못할 수도 있음.

#### 3) 이중 해싱(Double Hashing)
- 개념
    - 첫 번째 해시 함수는 초기 위치를 결정하고, 두 번째 해시 함수는 충돌 시 탐사 간격을 결정.
- 장점
    - 클러스터링 문제를 크게 감소시킴.
    - 선형 탐사나 제곱 탐사보다 더 균일한 분포를 제공.
    - 두 번째 해시 함수로 인해 충돌 해결 패턴이 다양함.
- 단점
    - 두 개의 해시 함수를 계산해야 하므로 약간의 추가 연산이 필요함.
    - 구현이 조금 더 복잡함.
    - 두 번째 해시 함수를 잘못 선택하면 성능 저하 가능.
  