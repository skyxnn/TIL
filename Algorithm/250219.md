**250219 | [Algorithm] Queue #1-1**

## [1] 큐
### 1. 큐
#### 1) 큐(Queue)
- 개념
    - 삽입(뒤)과 삭제(앞)의 위치가 제한적인 자료구조.
- 특징
    - 선입선출구조(FIFO; First In First Out) : 삽입한 순서대로 삭제.
- 구조
    - front : 저장된 원소 중 첫 번째 원소 / 삭제된 위치.
    - rear : 저장된 원소 중 마지막 원소.

### 2. 선형 큐
#### 1) 선형 큐의 상태 표현
- 상태 표현
    - 초기 : front = rear = -1
    - 공백 : front == rear
    - 포화 : rear == n-1 (n: 배열의 크기.)

#### 2) 선형 큐의 연산
- enqueue(x); 삽입 연산
    - `rear += 1`
    - rear 값을 하나 증가시켜 해당 인덱스의 배열 원소 `Q[rear]`에 원소 x 저장.
        - 마지막 원소 뒤에 새로운 원소 삽입.
- dequeue(); 삭제 연산.
    - `front -= 1`
    - front 값을 하나 증가 시켜 남아있는 첫 번째 원소로 이동하여 해당 원소를 리턴.
        - 가장 앞에 있는 원소를 삭제.
- isEmpty() / isFull(); 공백 // 포화 상태 검사.
    - 공백 : front == rear
    - 포화 : rear == n-1 (n : 배열의 크기.)
- Qpeek(); 검색.
    - 현재 front의 한 자리 뒤에 있는 원소(즉, 큐의 첫 번째에 있는 원소) 반환.
        - 가장 앞에 있는 원원소를 검색하여 반환.

#### 3) 선형 큐의 구현
- 방법
    - 1차원 배열을 이용.
    - Queue의 크기 = 배열의 크기.
    - front : 저장된 첫 번째 원소의 인덱스.
    - rear : 저장된 마지막 원소의 인덱스.
- 구현
    ```python
    # 선형 큐.
    # Create Queue.
    queue = [0] * 3
    front = rear = -1

    # enqueue(1); rear를 증가하고 저장하는 방식.
    rear += 1
    queue[rear] = 1

    # dequeue() #1; isEmpty() 검사 진행 X.
    front += 1
    print(queue[front])

    # dequeue() #2; isEmpty() 검사 진행 O.
    # Q에 원소가 남아 있는 경우.
    while front != rear:
        front += 1
        print(queue[front])
    ```

#### 4) 선형 큐의 문제점
- 문제점
    |index|[0]|[1]|[2]|[3]|
    |:-:|:-:|:-:|:-:|:-:|
    | Q |   |   |   |🟦|
    |pointer|   |   |front|rear|
    - 잘못된 포화상태 인식; 배열의 앞부분에 활용할 수 있는 공간이 있음에도 포화상태로 인식.
- 해결 방법
    1. 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동.
        - 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐.
    2. 1차원 배열을 사용하되 논리적으로는 배열이 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용.
        - 원형 큐의 논리적 구조.

### 3. 원형 큐
#### 1) 원형 큐의 상태 표현
- 상태 표현
    - 공백 : front = rear = 0
- 특징
    - 공백 상태와 포화 상태 구분을 위해 front가 있는 자리는 사용하지 않음.

#### 2) 원형 큐의 연산
- enqueue(x); 삽입 연산
    - `rear = (rear+1) mod N`
    - rear 값을 조저하여 새로운 원소를 삽입할 자리를 마련하고 해당 인덱스의 배열 Q[rear]에 x 저장.
        - 마지막 원소 뒤에 새로운 원소를 삽입.
- dequeue(); 삭제 연산.
    - `front = (front+1) mod M`
    - front 값을 조정하여 삭제할 자리를 준비하고 새로운 front 원소를 리턴.
        - 가장 앞에 있는 원소 삭제.
- ifFull(): 포화 상태 확인.
    - `(rear+1) % N == front`
- isEmpty(): 공백 상태 확인.
    - `front == rear`

### 4. 연결 큐
#### 1) 연결 큐
- 개념
    - 단순 연결 리스트(Linked List)를 이용한 큐.
        - 큐의 원소 : 단순 연결 리스트의 노드
        - 큐의 원소 순서 : 노드의 연결 순서, 링크로 연결되어 있음.
- 특징
    - 삽입 / 삭제가 효율적임.
- 구조
    - front : 첫 번째 노드를 가리키는 링크.
    - rear : 마지막 노드를 가리키는 링크.

#### 2) 연결 큐의 상태 표현
- 상태 표현
    - 초기 : front = rear = NULL
    - 공백 : front = rear = NULL

### 5. 덱
#### 1) 덱(deque)
- 개념
    - 양쪽 끝에서 추가와 삭제를 할 수 있는 구조.
- 연산
    - `append(x)` : 오른쪽에 x 추가.
    - `popleft()` : 왼쪽에서 요소를 제거하고 반환 / 요소가 없으면 IndexError
- 활용
    ```python
    from collections import deque

    # Create Deque.
    q = deque()

    # enqueue(1).
    q.append(1)

    # dequeue().
    t = q.popleft()
    print(t)
    ```

### 6. 우선순위 큐
#### 1) 우선순위 큐(Priority Queue)
- 개념
    - 우선순위를 가진 항목들을 저장하는 큐.
- 특징
    - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나감.
- 적용 분야
    - 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케줄링.

#### 2) 우선순위 큐의 구현
- 배열을 이용한 우선순위 큐의 구현.
    - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입.
        - 삽입 / 삭제 시 원소 재배치 발생.
    - 가장 앞에 최고 우선순위의 원소가 위치.

### 7. 스택과 큐의 상태 표현
#### 1) 스택과 큐의 상태 표현
- 상태 표현
    | **상태** | **스택** | **선형 큐** | **원형 큐** | **연결 큐** |
    | --- | --- | --- | --- | --- |
    | 초기 상태 | top == -1 | front == rear == -1 | front == rear == 0 | front == rear == null |
    | 공백 상태 | top == -1 | front == rear | front == rear | front == rear == null |
    | 포화 상태 | top == N - 1 | rear == N - 1 | (rear + 1) % n == front | ❌ |
    | 삽입 연산 | top = top + 1 | rear = rear + 1 | rear = (rear + 1) % n | rear.next = newNode;
    rear = newNode |
    | 삭제 연산 | top = top -1 | front = front + 1 | front = (front + 1) % n | front = front.next |

## [2] 큐의 활용
### 1. 버퍼
#### 1) 버퍼(Buffer)
- 개념
    - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역.
        - *버퍼링 : 버퍼를 활용하는 방식 / 버퍼를 채우는 동작.
- 특징
    - 입출력 및 네트워크와 관련된 기능에서 이용.
- 자료 구조
    - 큐; 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조 활용.
