**250205 | [Algorithm] List #1-2**

## [1] 정렬
### 1. 정렬
#### 1) 카운팅 정렬(Counting Sort)
- 개념
	- 집합에 각 항목이 몇 개씩 있는지 세는 작업을 통해 항목들의 순서를 결정하는 알고리즘.
- 제한 사항
	- 정수 / 정수 표현이 가능한 자료에 대해서만 적용 可.
	- 각 항목의 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 `COUNTS` 배열을 사용하기 때문.
	- `COUNTS` 배열의 충분한 공간을 할당하기 위해 집합 내의 가장 큰 정수를 알아야 함.
- 정렬 과정
    1. `DATA` 배열 내의 최댓값을 찾음.
    2. `COUNTS` 배열을 0으로 초기화하고, `DATA` 배열 내의 각 요소 개수를 `COUNTS` 배열에 저장.
    3. `COUNTS` 배열의 요소 개수를 누적합으로 재구성.
    4. `DATA` 배열 내의 마지막 요소부터 순차적으로 `COUNTS`의 누적합 -1 위치에 정렬.
- 시간 복잡도
	- $O(n+k)$
		- $n$은 리스트 길이, $k$는 정수의 최댓값.
- 특징
    - 안정성 (O); 동일한 키가 있을 때, 상대적 순서가 보존되기 때문.
    - 적응성 (X); 초기 정렬 상태에 따라 실행 시간이 바뀌지 않기 때문.
    - 제자리 정렬 (X); 정렬을 위한 다른 저장 공간(배열)을 사용하기 때문.
- 유리한 경우
    - 시험 성적 N 높 K 낮; N 학생 수 K 시험 성적(0~100).
---
- 예시
	1. `DATA`의 각 요소 개수를 세고, 각 요소가 인덱스가 되는 `COUNTS`에 저장. <br>
		| DATA | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
		|:---: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

		| COUNTS|  1  |  3  |  1  |  1  |  2  |
		| :---: |:---:|:---:|:---:|:---:|:---:|
		|*INDEX*|*[0]*|*[1]*|*[2]*|*[3]*|*[4]*|

	2. `COUNTS`의 원소를 개별 개수에서 \*누적합으로 조정.<br>
		&emsp;&emsp;\* 누적합 : DATA의 각 요소의 안정성을 보존하기 위하여 사용.
  
		| DATA | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
		|:---: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

		| COUNTS|  1  |  4  |  5  |  6  |  8  |
		| :---: |:---:|:---:|:---:|:---:|:---:|
		|*INDEX*|*[0]*|*[1]*|*[2]*|*[3]*|*[4]*|
		

	3. `DATA`의 각 요소를 `COUNTS`의 인덱스로 하고, 해당 인덱스에 있는 `COUNTS`의 요소를 $-1$한 것을 `TEMP` . <br>
		| DATA | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
		|:---: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
		|      |   |   |   |   |   |   |   |⬆️|

		| COUNTS|  1  | ~~4~~ → 3 |  5  |  6  |  8  |
		| :---: |:---:| :-------: |:---:|:---:|:---:|
		|*INDEX*|*[0]*|   *[1]*   |*[2]*|*[3]*|*[4]*|
		|       |     |    ⬆️     |     |     |     |

		| TEMP  |     |     |     |  1  |     |     |     |     |
		| :---: |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|*INDEX*|*[0]*|*[1]*|*[2]*|*[3]*|*[4]*|*[5]*|*[6]*|*[7]*|
		|       |     |     |     | ⬆️  |     |     |     |     |
	


	99. 결과. <br>
		| DATA | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
		|:---: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
		|      |⬆️ |   |   |   |   |   |   |   |

		| COUNTS|~~1~~ → 0|  1  |  4  |  5  |  6  |
		| :---: | :-----: |:---:|:---:|:---:|:---:|
		|*INDEX*|  *[0]*  |*[1]*|*[2]*|*[3]*|*[4]*|
		|       |    ⬆️   |     |     |     |     |

		| TEMP  |  0  |  1  |  1  |  1  |  2  |  3  |  4  |  4  |
		| :---: |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
		|*INDEX*|*[0]*|*[1]*|*[2]*|*[3]*|*[4]*|*[5]*|*[6]*|*[7]*|
		|       | ⬆️  |     |     |     |     |     |     |     |

- 코드
	```python
	def CountingSort(DATA, TEMP):
		N = len(DATA)
		COUNTS = [0] * (N+1)

		for i in range(N):
			COUNTS[DATA[i]] += 1

		for i in ranage(1, N+1):
			COUNTS[i] += COUNTS[i-1]
		
		for i in range(N-1, -1, -1):
			COUNTS[DATA[i]] -= 1
			TEMP[COUNTS[DATA[i]]] = DATA[i]
		
		return TEMP
	```

## [2] 완전 검색과 탐욕 알고리즘
### 1. 완전 검색
#### 1) 완전 검색(Exaustive Search; Brute-force; generate-and-test 기법)
- 개념
	- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
- 특징
    - 모든 경우의 수를 테스트한 후, 최종 해법을 도출.<br>
		→ 수행 속도는 느림 / 해답 찾아내지 못할 확률 낮음.<br>
		→ 경우의 수가 상대적으로 작을 때 유용.

### 2. 탐욕 알고리즘
#### 1) 탐욕 알고리즘(Greedy Algorithm)
- 개념
	- 최적해를 구하는 데 사용되는 근시안적인 방법.
	- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방법.
- 특징
	- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 동작 과정
	1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가.
	2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지(문제의 제약 조건을 위반하지 않는지) 확인.
	3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인, 전체 문제의 해가 완성되지 않았다면 1.부터 다시 시작.

### 3. 활용
#### 0) 순열(Permutation)
- 개념
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것.
    - $nPr = n * (n-1) * (n-2) * ... * 1 = n!$
- 예시 코드
	```python
	arr = [2, 3, 7]
	for i1 in range(3):
		for i2 in range(3):
			if i1 != i2:
				for i3 in range(3):
					if i1 != i3 and i2 != i3:
						print(arr[i1], arr[i2], arr[i3])
	```

#### 1) 예시 문제 #1; Baby-gin Game
- 설명
    - 0~9 사이의 숫자 카드에서 임의의 카드 6 장을 뽑았을 때 , 3 장의 카드가
연속적인 번호를 갖는 경우를 run 이라 하고 , 3 장의 카드가 동일한 번호를 갖는
경우를 triplet 이라고 한다.
	- 그리고 , 6 장의 카드가 run 과 triplet 로만 구성된 경우를 baby gin 으로 부른다.
	- 6 자리의 숫자를 입력 받아 baby gin 여부를 판단하는 프로그램을 작성하라.
- 입력 예시
    - 667767은 두 개의 triplet이므로 baby-gin이다. (666, 777)
    - 054060은 한 개의 triplet과 한 개의 run이므로 baby-gin이다. (000, 456)
    - 101123은 한 개의 triplet이 존재하나, 023이 run이 아니므로 baby-gin이 아니다.
- 접근 방법 #1; 완전 검색
	```python
	```

- 접근 방법 #2; 탐욕 알고리즘
	```python
	num = int(input())
	c = [0] * 12            # c[10], c[11]은 c[9]의 run을 확인하기 위함.

	for _ in range(6):
		c[num % 10] += 1    # 1의 자리 찾기.
		num //= 10          # 1의 자리 제거.

	i = 0
	tri = run = 0
	while i < 10:           # 카드 번호가 10 미만.
		# triplet 확인.
		if c[i] >= 3:
			c[i] -= 3
			tri += 1
			continue

		# run 확인.
		if c[i] >= 1 and c[i+1] >= 1 and c[i+1] >= 1:
			c[i] -= 1
			c[i+1] -= 1
			c[i+2] -= 1
			run += 1
			continue
		i += 1

	if run + tri == 2:
		print('Baby Gin')
	else:
		print('Lose')

	print(c)
	```

# 추가
정렬
- 안정성 : 동일한 키가 있을 때, 상대적 순서가 보존되는 것.
    - 버블 정렬은 안정성이 있다.
- 적응성 : 초기 정렬 상태에 따라 실행 시간이 바뀌는 것.

제자리 정렬 : 외부 메모리의 사용하지 않는 것.
	- 버블 정렬은 제자리 정렬이다.