**250207 | [Algorithm] List #2-1**

## [1] 2차원 배열
### 1. 2차원 배열
#### 1) 2차원 배열
- 개념
    - 1차원 list를 묶어놓은 list.
- 선언
    - 세로(행) 길이와 가로(열) 길이를 필요로 함.
    - *2차원 이상의 다차원 list는 차원에 따라 Index를 선언.
- 예시 #1
    |*arr*|*0*|*1*|*2*|*3*|
    |:---:|:-:|:-:|:-:|:-:|
    | *0* | 0 | 1 | 2 | 3 |
    | *1* | 4 | 5 | 6 | 7 |
    ```python
    # 기본 2차원 배열
    arr = [[0, 1, 2, 3], [4, 5, 6, 7]]
    ```
- 예시 #2
    ```python
    # 아래와 같은 형태의 입력을 2차원 배열에 저장.
    '''
    3
    123
    456
    789
    '''
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    ```
- 예시 #3
    ```python
    # N x M 배열에 0으로 채우기
    N = int(input())
    M = int(input())
    arr = [[0] * M for _ in range(N)]
    # [[0] * M] * N : (X); 얕은 복사로 같은 객체를 참조함.
    ```

### 2. 순회
#### 1) 배열 순회
- 개념
    - $n \times m$ 배열의 $n * m$ 개의 모든 원소를 빠짐 없이 조사하는 방법.

#### 2) 행 우선 순회
- 코드
    ```python
    # i 행의 좌표, j 행의 좌표
    for i in range(n):
        for j in range(m):
            print(arr[i][j])
    ```
- 활용
    ```python
    # N x M 배열의 행의 합 중 최댓값 구하기.
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    max_sum = 0
    for i in range(N):
        row_sum = 0
        for j in range(M):
            row_sum += arr[i][j]
        if max_sum < row sum:
            max_sum = row_sum
    ```

#### 3) 열 우선 순회
- 코드
    ```python
    # i 행의 좌표, j 행의 좌표
    for j in range(m):
        for i in range(n):
            print(arr[i][j])
    ```

#### 4) 지그재그 순회
- 코드
    ```python
    # 지그재그 순회
    # i 행의 좌표, j 행의 좌표
    for i in range(n):
        for j in range(m):
            print(arr[i][j + (m-1-2*j) * (i%2)])
    # 홀수인 경우 j의 인덱스는 m - 1 - j여야 함.
    # j + (m - 1 - 2*j) = m - 1 - j
    '''
    if i % 2: j = 0 -> m-1
    else: j = m-1 -> 0
    '''
    ```

## [2] 2차원 배열의 활용
### 1. 델타
#### 1) 델타를 이용한 2차원 배열의 탐색
- 개념
    - 2차원 배열의 한 좌표에서 네 방향의 인접 배열 요소를 탐색하는 방법.
- 탐색 범위
    - 인덱스 ($i$, $j$)인 칸의 상하좌우 칸($n_i$, $n_j$)

        ||j-1|j|j+1|
        |:-:|:-:|:-:|:-:|
        |**i-1**||3️⃣ (i-1, j)||
        |**i**|2️⃣ (i, j-1)|(i, j)|0️⃣ (i, j+1)|
        |**i+1**||1️⃣ (i+1, j)||
- 코드
    ```python
    # 방법 1
    N = 2
    M = 3

    di = [0, 1, 0, -1]      # 오른쪽부터 시계 방향으로.
    dj = [1, 0, -1, 0]
    for i in range(N):
        for j in range(M):
            for dirc in range(4):
                ni = i + di[dirc]
                nj = j + di[dirc]
                # 벗어나는 좌표 제거.
                if 0 <= ni < N and 0 <= nj < M:
                    print(ni, nj)
    ```

    ```python
    # 방법 2
    N = 2
    M = 3

    for i in range(N):
        for j in range(M):
            for di, dj in [[0, 1], [-1, 0], [0, -1], [-1, 0]]:
                ni, nj = i + di, j + dj
                # 벗어나는 좌표 제거.
                if 0 <= ni < N and 0 <= nj < M:
                    print(ni, nj)
    ```

#### 2) 델타 응용
- 문제
    - $N \times N$ 배열에서 각 원소를 중싱으로 상하좌우 $k$칸의 합계 중 최댓값($k=2$)

### 2. 전치 행렬
#### 1) 전치 행렬
- 코드
    ```python
    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    i = len(arr)
    j = len(arr[0])

    for i in range(3):
        for j in range(3):
            if i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j] 
    ```

#### 2) $i$, $j$의 크기에 따라 접근하는 원소 비교($N \times N$)
```python
for i in range(N):
    for j in range(N):
        if #______ :
```
1. `i < j`
    ||*0*|*1*|*2*|
    |:-:|:-:|:-:|:-:|
    |***0***||🟦|🟦|
    |***1***|||🟦|
    |***2***||||
2. `i > j`
    ||*0*|*1*|*2|
    |:-:|:-:|:-:|:-:|
    |***0***||||
    |***1***|🟦|||
    |***2***|🟦|🟦||
3. `i == j`
    ||*0*|*1*|*2*|
    |:-:|:-:|:-:|:-:|
    |***0***|🟦|||
    |***1***||🟦||
    |***2***|||🟦|
4. `N-1-i == j`
    ||*0*|*1*|*2*|
    |:-:|:-:|:-:|:-:|
    |***0***|||🟦|
    |***1***||🟦||
    |***2***|🟦|||

### 3. 연습문제
#### 1) 연습문제 #1
- 문제
    - $5 \times 5$의 2차원 배열에 25개의 숫자를 저장하고, 대각선 원소의 합을 구하시오.
        - 대각선 원소는 다음과 같은 위치의 원소를 나타낸다.
            |       |*0*|*1*|*2*|*4*|*5*|
            |:-----:|:-:|:-:|:-:|:-:|:-:|
            |***0***|🟦|   |   |   |🟦|
            |***1***|   |🟦|   |🟦|   |
            |***2***|   |   |🟦|   |   |
            |***3***|   |🟦|   |🟦|   |
            |***4***|🟦|   |   |   |🟦|
- 코드
    ```python
    ```

## [3] 부분집합
### 1. 부분집합
#### 1) 부분집합 합(Subset Sum) 문제
- 개념
    - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제.
- 방법
    - 완전 검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산.
- 부분집합의 수
    - 집합의 원소의 수 = $n$
    - 부분집합의 수(공집합 포함) = $2^n$
        - 각 원소를 부분집합에 포함 여부의 2가지 경우를 모두 적용한 것.

#### 2) 부분집합 생성
- 코드
    ```python
    bit = [0, 0, 0, 0]

    for i in range(2):
        bit[0] = i
        for j in range(2):
            bit[1] = i
            for 
    ```

### 2. 비트 연산자
#### 1) 비트 연산자
- 개념
    - 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자.
- 종류
    - `&` : 비트 단위의 AND 연산.
    - `|` : 비트 단위의 OR 연산.
    - `<<` : 피연산자의 비트 열을 왼쪽으로 이동.
    - `>>` : 피연산자의 비트 열을 오른쪽으로 이동.
- 부분집합의 수
    - `1 << n` : $n$번 비트가 1인 값; $2^n$. 즉, 원소가 n개 일 경우의 모든 부분집합의 수..
- 비트의 1 여부
    - `i & (1 << j)` : $i$의 $j$번째 비트가 1인지 아닌지 검사.

#### 2) 비트 연산자를 활용한 부분집합 생성
- 코드
```python
    arr = [3, 6, 7]
    n = len(arr)

    for i in range(1<<n):       # 부분집합의 개수만큼 반복.
        for j in range(n):
            if i & (1<<j):      # i의 j번 비트가 1인 경우.
                print(arr[j], end=',')
        print()
    print()
```

## [0] 2차원 배열의 회전
### 0. 전치
#### 1) 전치
- 
```python
original_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

```

### 1. 2차원 배열의 회전
#### 1) 시계 방향으로 90도 회전
```python
original_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

```