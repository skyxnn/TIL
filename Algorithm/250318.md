**250318 | [Algorithm2] 백트래킹 #1**

## [1] 백트래킹
### 1. 백트래킹
#### 1) 백트래킹(Backtracking)
- 개념
    - 어떤 노드의 유망성을 점검한 후 유망하지 ㅇ
- 방법
    1. 상태 공간 트리의 깊이 우선 검색을 실시.
    2. 각 노드가 유망한지를 점검.
    3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 계속 검색.
- Backtracking vs. DFS
    - DFS : 모든 경로를 추적.
    - Backtracking : ***가지치기(Prunning)**를 통해 불필요한 경로를 조기에 차단.
        - ***가지치기(Prunning)** : 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임.

### 2. 예시 문제
#### 1) N-Queen
- 코드
    ```python
    # 4x4

    '''
    일차원 배열 활용 방법
    if abs(visited[row] - visited[col]) == abs(row - col):
        return False
    '''


    def check(row, col):
        # 1. 같은 열.
        for i in range(row):
            if visited[i][col]:
                return False

        # 2. 왼쪽 대각선 (\)
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if visited[i][j]:
                return False

            i -= 1
            j -= 1

        # 3. 오른쪽 대각선 (/)
        i, j = row -1, col + 1
        while i >= 0 and j < N:
            if visited[i][j]:
                return False

            i -= 1
            j += 1

        # 위의 경우의 수를 모두 통과한 경우, True
        return True


    # level : N개의 행에 모두 놓음.
    # branch : N개의 열
    def dfs(row):
        global answer

        # N개의 행에 모두 놓으면, 성공.
        if row == N:
            answer += 1
            return

        # 후보군; N개의 열.
        for col in range(N):
            # 기존에 같은 열이나 대각선에 놓은 적 있으면 불가능.
            if check(row, col):
                visited[row][col] = 1
                dfs(row + 1)
                visited[row][col] = 0


    N = 4
    visited = [[0] * N for _ in range(N)]
    answer = 0
    dfs(0)
    print(answer)
    ```

## [2] 트리
### 1. 트리
#### 1) 트리(Tree)
- 개념
    - 싸이클이 없는 무향 연결 그래프.
- 특징
    - 두 노드 사이에는 유일한 경로가 존재.
    - 각 노드는 최대 하나의 부모 노드가 존재.
    - 각 노드는 자식 노드가 없거나 하나 이상 존재 가능.
    - 비선형 구조(원소들 간에 1:n 관계를 가지는 자료 구조)

### 2. 이진 탐색 트리
#### 1) 이진 탐색 트리(BST; Binary Search Tree)
- 개념
    - 탐색 작업을 효율적으로 하기 위한 자료 구조.
    - key(왼쪽 서브 트리) < key(루트 노드) < key(오른쪽 서브 트리)
- 탐색 연산
    1. 루트에서 탐색 시작.
    2. 탐색할 키 값 x를 루트 노드의 키 값 k와 비교.
        - x == k : 탐색 성공.
        - x < k : 루트 노드의 왼쪽 서브 트리에 대해서 탐색 연산 수행.
        - x > k : 루트 노드의 오른쪽 서브 트리에 대해서 탐색 연산 수행.
    3. 서브 트리에 대해서 순환적으로 탐색 연산을 반복.
    4. 탐색할 서브 트리가 없으면 탐색 실패.
- 삽입 연산
    1. 탐색 연산을 수행.
        - 삽입할 원소와 같은 원소가 트리에 있으면 삽입 不可.
        - 탐색에서 탐색 실패가 결정되는 위치를 삽입 위치로 결정.
    2. 탐색 실패한 위치에 원소 삽입.
- 삭제 연산
    1. 탐색 연산을 수행.
    2. 삭제 연산을 수행.
        - 리프 노드의 경우, 해당 노드 삭제.
        - 자식이 한 개인 노드의 경우, 부모 노드와 자식 노드를 연결.
        - 자식이 두 개인 노드의 경우, 후보(왼쪽의 최댓값/오른쪽의 최솟값)를 해당 위치로 이동.
- 성능
    - 탐색, 삽입, 삭제 시간 : O(h) ; BST의 깊이(height)
    - 평균 : O(log n) ; 균형적으로 생성된 경우.
    - 최악 : O(n) ; 편향 이진 트리의 경우.

### 3. 힙 트리
#### 1) ⭐ 힙 트리(Heap Tree)
- 개념
    - 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해 만든 자료 구조.
- 특징
    - 자식들 간의 대소 비교는 不可.
- 종류
    - 최대 힙(max heap) : 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리.
    - 최소 힙(min heap) : 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리.
- 삽입 연산
    1. 삽입할 자리 확장.
    2. 확장한 자리에 삽입할 원소 저장.
    3. 삽입 노드가 부모 노드보다 크면 부모 노드와 자리 교환하여 자리 확정.
- 삭제 연산
    1. 루트 노드의 원소를 삭제하여 반환.
        - 힙에서는 루트 노드의 원소만 삭제 可.
    2. 마지막 노드를 삭제하고 루트 노드로 이동.
    3. 자식 노드와의 값 비교를 통해 자리 확정.
- 활용
    1. 특별한 큐의 구현
    2. 정렬
        - 데이터 추가를 하되, 정렬된 구조를 유지해야 하는 경우.
- 코드
    ```python
    import heapq

    arr = [20, 15, 19, 4, 13, 11]
    # 1. 기본 리스트를 최소 힙으로 만들기
    # *디버깅 시에 이진 트리로 그림을 그려야 함.
    heapq.heapify(arr)
    print(arr)

    # 2. 하나씩 데이터를 추가하기.
    min_heap = []
    for num in arr:
        heapq.heappush(min_heap, num)
    print(min_heap)

    # *최대 힙은 음수로 변환하여 구현 가능.
    max_heap = []
    for num in arr:
        heapq.heappush(max_heap, -num)
    print(max_heap)
    ```
